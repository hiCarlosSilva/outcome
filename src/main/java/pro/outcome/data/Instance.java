// All the information contained in this source code file is a property of Outcome Professional Services Limited,
// a company registered in the United Kingdom. Use and distribution of any part of the information 
// contained in this source code file without our prior consent is forbidden. If you have an interest 
// in using any part of this source code in your software, please contact hiCarlosSilva@gmail.com.
package pro.outcome.data;
import java.util.Date;
import java.util.Iterator;
import java.util.Map;
import java.util.HashMap;
import java.util.Set;
import com.google.appengine.api.datastore.Entity;

import pro.outcome.util.Checker;
import pro.outcome.util.IntegrityException;


public abstract class Instance<M extends Model> {

	private Entity _e;
	private final Map<Field<?>,Object> _updates;
	
	protected Instance() {
		_e = new Entity(getModel().getEntityName());
		_updates = new HashMap<>();
	}

	protected Instance(Long id) {
		Checker.checkNull(id, "id");
		Checker.checkMinValue(id, 1, "id");
		_e = new Entity(getModel().getEntityName(), id);
		_updates = new HashMap<>();
	}
	
	// For Facade:
	// TODO make package
	public Instance(Entity e) {
		Checker.checkNull(e, "e");
		_e = e;
		_updates = new HashMap<>();
	}

	public boolean equals(Object o) {
		if(o == null) {
			return false;
		}
		if(this == o) {
			return true;
		}
		if(!(o instanceof Instance)) {
			return false;
		}
		return _e.equals(((Instance<?>)o)._e);
	}
	
	public int hashCode() {
		return _e.hashCode();
	}
	
	public String toString() {
		StringBuilder sb = new StringBuilder(getModel().getEntityName());
		sb.append(':');
		sb.append(' ');
		Iterator<Field<?>> it = getModel().getFields().values().iterator(); 
		while(it.hasNext()) {
			Field<?> f = it.next();
			sb.append('[');
			sb.append(f.getName());
			sb.append('=');
			sb.append(getValue(f));
			sb.append(']');
			if(it.hasNext()) {
				sb.append(' ');
			}
		}
		return sb.toString();
	}

	public abstract M getModel();

	public final Long getId() { return _e.getKey().getId(); }
	public final Date getTimeCreated() { return getValue(getModel().timeCreated); }
	public final Date getTimeUpdated() { return getValue(getModel().timeUpdated); }

	@SuppressWarnings("unchecked")
	protected <T> T getValue(Field<T> f) {
		Checker.checkNull(f,  "f");
		if(_updates.containsKey(f)) {
			return (T)_updates.get(f);
		}
		return (T)_e.getProperty(f.getName());
	}

	protected <T> void setValue(Field<T> f, T value) {
		Checker.checkNull(f,  "f");
		// Check if setting a field that pertains to this entity:
		if(!getModel().getFields().containsValue(f)) {
			throw new IllegalArgumentException("field "+f.getFullName()+" cannot be used in entity "+getModel().getEntityName());
		}
		// Primary key:
		if(f == getModel().id) {
			throw new IllegalArgumentException("cannot set primary key");
		}
		// Validate data type (it should be enforced by the compiler):
		if(value != null) {
			if(value.getClass() != f.getType()) {
				throw new IntegrityException(value.getClass());
			}
		}
		// Validate format:
		// TODO
		// if(f.getValidator() != null) {
		// Validate mandatory constraint:
		if(value == null && f.isMandatory()) {
			throw new MandatoryConstraintException(f);
		}
		// Validate read-only constraint:
		if(willUpdate()) {
			if(f.isReadOnly()) {
				throw new ReadOnlyConstraintException(f, value);
			}
		}
		// Validate auto-gen constraint:
		if(f.isAutoGenerated()) {
			throw new AutoGenConstraintException(f, value);
		}
		// Track update:
		_updates.put(f,  value);
		// Check if the field is being set to its current value:
		Object current = _e.getProperty(f.getName());
		if(value == null) {
			if(current == null) {
				_updates.remove(f);
			}
		}
		else {
			if(value.equals(current)) {
				_updates.remove(f);
			}
		}
	}

	public boolean hasUpdates() {
		return _updates.size() > 0;
	}

	// For Facade:
	Entity getContainer() {
		return _e;
	}

	// For Facade._createFrom:
	void setContainer(Entity e) {
		_updates.clear();
		//_e.setPropertiesFrom(e);
		_e = e;
	}
	
	// For Facade
	boolean willInsert() {
		return !_e.getKey().isComplete();
	}
	
	// For Facade
	boolean willUpdate() {
		return _e.getKey().isComplete();
	}
	
	// For Facade:
	Set<Map.Entry<Field<?>,Object>> getUpdates() {
		return new HashMap<Field<?>,Object>(_updates).entrySet();
	}

	// For Facade:
	void flush(Field<?> f, Object value) {
		_updates.remove(f);
		if(f.isIndexed()) {
			_e.setProperty(f.getName(), value);
		}
		else {
			_e.setUnindexedProperty(f.getName(), value);
		}
	}
}
